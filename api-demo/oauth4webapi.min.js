/**
 * Minified by jsDelivr using Terser v5.39.0.
 * Original file: /npm/oauth4webapi@3.6.0/build/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
let USER_AGENT;if("undefined"==typeof navigator||!navigator.userAgent?.startsWith?.("Mozilla/5.0 ")){USER_AGENT=`${"oauth4webapi"}/${"v3.6.0"}`}function looseInstanceOf(e,t){if(null==e)return!1;try{return e instanceof t||Object.getPrototypeOf(e)[Symbol.toStringTag]===t.prototype[Symbol.toStringTag]}catch{return!1}}const ERR_INVALID_ARG_VALUE="ERR_INVALID_ARG_VALUE",ERR_INVALID_ARG_TYPE="ERR_INVALID_ARG_TYPE";function CodedTypeError(e,t,s){const r=new TypeError(e,{cause:s});return Object.assign(r,{code:t}),r}export const allowInsecureRequests=Symbol();export const clockSkew=Symbol();export const clockTolerance=Symbol();export const customFetch=Symbol();export const modifyAssertion=Symbol();export const jweDecrypt=Symbol();export const jwksCache=Symbol();const encoder=new TextEncoder,decoder=new TextDecoder;function buf(e){return"string"==typeof e?encoder.encode(e):decoder.decode(e)}let encodeBase64Url,decodeBase64Url,jwkCache;if(Uint8Array.prototype.toBase64)encodeBase64Url=e=>(e instanceof ArrayBuffer&&(e=new Uint8Array(e)),e.toBase64({alphabet:"base64url",omitPadding:!0}));else{const e=32768;encodeBase64Url=t=>{t instanceof ArrayBuffer&&(t=new Uint8Array(t));const s=[];for(let r=0;r<t.byteLength;r+=e)s.push(String.fromCharCode.apply(null,t.subarray(r,r+e)));return btoa(s.join("")).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_")}}function b64u(e){return"string"==typeof e?decodeBase64Url(e):encodeBase64Url(e)}decodeBase64Url=Uint8Array.fromBase64?e=>{try{return Uint8Array.fromBase64(e,{alphabet:"base64url"})}catch(e){throw CodedTypeError("The input to be decoded is not correctly encoded.",ERR_INVALID_ARG_VALUE,e)}}:e=>{try{const t=atob(e.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"")),s=new Uint8Array(t.length);for(let e=0;e<t.length;e++)s[e]=t.charCodeAt(e);return s}catch(e){throw CodedTypeError("The input to be decoded is not correctly encoded.",ERR_INVALID_ARG_VALUE,e)}};export class UnsupportedOperationError extends Error{code;constructor(e,t){super(e,t),this.name=this.constructor.name,this.code=UNSUPPORTED_OPERATION,Error.captureStackTrace?.(this,this.constructor)}}export class OperationProcessingError extends Error{code;constructor(e,t){super(e,t),this.name=this.constructor.name,t?.code&&(this.code=t?.code),Error.captureStackTrace?.(this,this.constructor)}}function OPE(e,t,s){return new OperationProcessingError(e,{code:t,cause:s})}function assertCryptoKey(e,t){if(!(e instanceof CryptoKey))throw CodedTypeError(`${t} must be a CryptoKey`,ERR_INVALID_ARG_TYPE)}function assertPrivateKey(e,t){if(assertCryptoKey(e,t),"private"!==e.type)throw CodedTypeError(`${t} must be a private CryptoKey`,ERR_INVALID_ARG_VALUE)}function assertPublicKey(e,t){if(assertCryptoKey(e,t),"public"!==e.type)throw CodedTypeError(`${t} must be a public CryptoKey`,ERR_INVALID_ARG_VALUE)}function normalizeTyp(e){return e.toLowerCase().replace(/^application\//,"")}function isJsonObject(e){return null!==e&&"object"==typeof e&&!Array.isArray(e)}function prepareHeaders(e){looseInstanceOf(e,Headers)&&(e=Object.fromEntries(e.entries()));const t=new Headers(e??{});if(USER_AGENT&&!t.has("user-agent")&&t.set("user-agent",USER_AGENT),t.has("authorization"))throw CodedTypeError('"options.headers" must not include the "authorization" header name',ERR_INVALID_ARG_VALUE);return t}function signal(e,t){if(void 0!==t){if("function"==typeof t&&(t=t(e.href)),!(t instanceof AbortSignal))throw CodedTypeError('"options.signal" must return or be an instance of AbortSignal',ERR_INVALID_ARG_TYPE);return t}}function replaceDoubleSlash(e){return e.includes("//")?e.replace("//","/"):e}function prependWellKnown(e,t,s=!1){return"/"===e.pathname?e.pathname=t:e.pathname=replaceDoubleSlash(`${t}/${s?e.pathname:e.pathname.replace(/(\/)$/,"")}`),e}function appendWellKnown(e,t){return e.pathname=replaceDoubleSlash(`${e.pathname}/${t}`),e}async function performDiscovery(e,t,s,r){if(!(e instanceof URL))throw CodedTypeError(`"${t}" must be an instance of URL`,ERR_INVALID_ARG_TYPE);checkProtocol(e,!0!==r?.[allowInsecureRequests]);const o=s(new URL(e.href)),n=prepareHeaders(r?.headers);return n.set("accept","application/json"),(r?.[customFetch]||fetch)(o.href,{body:void 0,headers:Object.fromEntries(n.entries()),method:"GET",redirect:"manual",signal:signal(o,r?.signal)})}export async function discoveryRequest(e,t){return performDiscovery(e,"issuerIdentifier",(e=>{switch(t?.algorithm){case void 0:case"oidc":appendWellKnown(e,".well-known/openid-configuration");break;case"oauth2":prependWellKnown(e,".well-known/oauth-authorization-server");break;default:throw CodedTypeError('"options.algorithm" must be "oidc" (default), or "oauth2"',ERR_INVALID_ARG_VALUE)}return e}),t)}function assertNumber(e,t,s,r,o){try{if("number"!=typeof e||!Number.isFinite(e))throw CodedTypeError(`${s} must be a number`,ERR_INVALID_ARG_TYPE,o);if(e>0)return;if(t){if(0!==e)throw CodedTypeError(`${s} must be a non-negative number`,ERR_INVALID_ARG_VALUE,o);return}throw CodedTypeError(`${s} must be a positive number`,ERR_INVALID_ARG_VALUE,o)}catch(e){if(r)throw OPE(e.message,r,o);throw e}}function assertString(e,t,s,r){try{if("string"!=typeof e)throw CodedTypeError(`${t} must be a string`,ERR_INVALID_ARG_TYPE,r);if(0===e.length)throw CodedTypeError(`${t} must not be empty`,ERR_INVALID_ARG_VALUE,r)}catch(e){if(s)throw OPE(e.message,s,r);throw e}}export async function processDiscoveryResponse(e,t){const s=e;if(!(s instanceof URL)&&s!==_nodiscoverycheck)throw CodedTypeError('"expectedIssuerIdentifier" must be an instance of URL',ERR_INVALID_ARG_TYPE);if(!looseInstanceOf(t,Response))throw CodedTypeError('"response" must be an instance of Response',ERR_INVALID_ARG_TYPE);if(200!==t.status)throw OPE('"response" is not a conform Authorization Server Metadata response (unexpected HTTP status code)',RESPONSE_IS_NOT_CONFORM,t);assertReadableResponse(t);const r=await getResponseJsonBody(t);if(assertString(r.issuer,'"response" body "issuer" property',INVALID_RESPONSE,{body:r}),s!==_nodiscoverycheck&&new URL(r.issuer).href!==s.href)throw OPE('"response" body "issuer" property does not match the expected value',JSON_ATTRIBUTE_COMPARISON,{expected:s.href,body:r,attribute:"issuer"});return r}function assertApplicationJson(e){assertContentType(e,"application/json")}function notJson(e,...t){let s='"response" content-type must be ';if(t.length>2){const e=t.pop();s+=`${t.join(", ")}, or ${e}`}else 2===t.length?s+=`${t[0]} or ${t[1]}`:s+=t[0];return OPE(s,RESPONSE_IS_NOT_JSON,e)}function assertContentTypes(e,...t){if(!t.includes(getContentType(e)))throw notJson(e,...t)}function assertContentType(e,t){if(getContentType(e)!==t)throw notJson(e,t)}function randomBytes(){return b64u(crypto.getRandomValues(new Uint8Array(32)))}export function generateRandomCodeVerifier(){return randomBytes()}export function generateRandomState(){return randomBytes()}export function generateRandomNonce(){return randomBytes()}export async function calculatePKCECodeChallenge(e){return assertString(e,"codeVerifier"),b64u(await crypto.subtle.digest("SHA-256",buf(e)))}function getKeyAndKid(e){return e instanceof CryptoKey?{key:e}:e?.key instanceof CryptoKey?(void 0!==e.kid&&assertString(e.kid,'"kid"'),{key:e.key,kid:e.kid}):{}}function psAlg(e){switch(e.algorithm.hash.name){case"SHA-256":return"PS256";case"SHA-384":return"PS384";case"SHA-512":return"PS512";default:throw new UnsupportedOperationError("unsupported RsaHashedKeyAlgorithm hash name",{cause:e})}}function rsAlg(e){switch(e.algorithm.hash.name){case"SHA-256":return"RS256";case"SHA-384":return"RS384";case"SHA-512":return"RS512";default:throw new UnsupportedOperationError("unsupported RsaHashedKeyAlgorithm hash name",{cause:e})}}function esAlg(e){switch(e.algorithm.namedCurve){case"P-256":return"ES256";case"P-384":return"ES384";case"P-521":return"ES512";default:throw new UnsupportedOperationError("unsupported EcKeyAlgorithm namedCurve",{cause:e})}}function keyToJws(e){switch(e.algorithm.name){case"RSA-PSS":return psAlg(e);case"RSASSA-PKCS1-v1_5":return rsAlg(e);case"ECDSA":return esAlg(e);case"Ed25519":case"EdDSA":return"Ed25519";default:throw new UnsupportedOperationError("unsupported CryptoKey algorithm name",{cause:e})}}function getClockSkew(e){const t=e?.[clockSkew];return"number"==typeof t&&Number.isFinite(t)?t:0}function getClockTolerance(e){const t=e?.[clockTolerance];return"number"==typeof t&&Number.isFinite(t)&&-1!==Math.sign(t)?t:30}function epochTime(){return Math.floor(Date.now()/1e3)}function assertAs(e){if("object"!=typeof e||null===e)throw CodedTypeError('"as" must be an object',ERR_INVALID_ARG_TYPE);assertString(e.issuer,'"as.issuer"')}function assertClient(e){if("object"!=typeof e||null===e)throw CodedTypeError('"client" must be an object',ERR_INVALID_ARG_TYPE);assertString(e.client_id,'"client.client_id"')}function formUrlEncode(e){return encodeURIComponent(e).replace(/(?:[-_.!~*'()]|%20)/g,(e=>{switch(e){case"-":case"_":case".":case"!":case"~":case"*":case"'":case"(":case")":return`%${e.charCodeAt(0).toString(16).toUpperCase()}`;case"%20":return"+";default:throw new Error}}))}export function ClientSecretPost(e){return assertString(e,'"clientSecret"'),(t,s,r,o)=>{r.set("client_id",s.client_id),r.set("client_secret",e)}}export function ClientSecretBasic(e){return assertString(e,'"clientSecret"'),(t,s,r,o)=>{const n=formUrlEncode(s.client_id),a=formUrlEncode(e),i=btoa(`${n}:${a}`);o.set("authorization",`Basic ${i}`)}}function clientAssertionPayload(e,t){const s=epochTime()+getClockSkew(t);return{jti:randomBytes(),aud:e.issuer,exp:s+60,iat:s,nbf:s,iss:t.client_id,sub:t.client_id}}export function PrivateKeyJwt(e,t){const{key:s,kid:r}=getKeyAndKid(e);return assertPrivateKey(s,'"clientPrivateKey.key"'),async(e,o,n,a)=>{const i={alg:keyToJws(s),kid:r},c=clientAssertionPayload(e,o);t?.[modifyAssertion]?.(i,c),n.set("client_id",o.client_id),n.set("client_assertion_type","urn:ietf:params:oauth:client-assertion-type:jwt-bearer"),n.set("client_assertion",await signJwt(i,c,s))}}export function ClientSecretJwt(e,t){assertString(e,'"clientSecret"');const s=t?.[modifyAssertion];let r;return async(t,o,n,a)=>{r||=await crypto.subtle.importKey("raw",buf(e),{hash:"SHA-256",name:"HMAC"},!1,["sign"]);const i={alg:"HS256"},c=clientAssertionPayload(t,o);s?.(i,c);const p=`${b64u(buf(JSON.stringify(i)))}.${b64u(buf(JSON.stringify(c)))}`,u=await crypto.subtle.sign(r.algorithm,r,buf(p));n.set("client_id",o.client_id),n.set("client_assertion_type","urn:ietf:params:oauth:client-assertion-type:jwt-bearer"),n.set("client_assertion",`${p}.${b64u(new Uint8Array(u))}`)}}export function None(){return(e,t,s,r)=>{s.set("client_id",t.client_id)}}export function TlsClientAuth(){return None()}async function signJwt(e,t,s){if(!s.usages.includes("sign"))throw CodedTypeError('CryptoKey instances used for signing assertions must include "sign" in their "usages"',ERR_INVALID_ARG_VALUE);const r=`${b64u(buf(JSON.stringify(e)))}.${b64u(buf(JSON.stringify(t)))}`;return`${r}.${b64u(await crypto.subtle.sign(keyToSubtle(s),s,buf(r)))}`}export async function issueRequestObject(e,t,s,r,o){assertAs(e),assertClient(t),s=new URLSearchParams(s);const{key:n,kid:a}=getKeyAndKid(r);assertPrivateKey(n,'"privateKey.key"'),s.set("client_id",t.client_id);const i=epochTime()+getClockSkew(t),c={...Object.fromEntries(s.entries()),jti:randomBytes(),aud:e.issuer,exp:i+60,iat:i,nbf:i,iss:t.client_id};let p;s.has("resource")&&(p=s.getAll("resource"))&&p.length>1&&(c.resource=p);{let e=s.get("max_age");null!==e&&(c.max_age=parseInt(e,10),assertNumber(c.max_age,!0,'"max_age" parameter'))}{let e=s.get("claims");if(null!==e){try{c.claims=JSON.parse(e)}catch(e){throw OPE('failed to parse the "claims" parameter as JSON',PARSE_ERROR,e)}if(!isJsonObject(c.claims))throw CodedTypeError('"claims" parameter must be a JSON with a top level object',ERR_INVALID_ARG_VALUE)}}{let e=s.get("authorization_details");if(null!==e){try{c.authorization_details=JSON.parse(e)}catch(e){throw OPE('failed to parse the "authorization_details" parameter as JSON',PARSE_ERROR,e)}if(!Array.isArray(c.authorization_details))throw CodedTypeError('"authorization_details" parameter must be a JSON with a top level array',ERR_INVALID_ARG_VALUE)}}const u={alg:keyToJws(n),typ:"oauth-authz-req+jwt",kid:a};return o?.[modifyAssertion]?.(u,c),signJwt(u,c,n)}async function getSetPublicJwkCache(e){const{kty:t,e:s,n:r,x:o,y:n,crv:a}=await crypto.subtle.exportKey("jwk",e),i={kty:t,e:s,n:r,x:o,y:n,crv:a};return jwkCache.set(e,i),i}async function publicJwk(e){return jwkCache||=new WeakMap,jwkCache.get(e)||getSetPublicJwkCache(e)}const URLParse=URL.parse?(e,t)=>URL.parse(e,t):(e,t)=>{try{return new URL(e,t)}catch{return null}};export function checkProtocol(e,t){if(t&&"https:"!==e.protocol)throw OPE("only requests to HTTPS are allowed",HTTP_REQUEST_FORBIDDEN,e);if("https:"!==e.protocol&&"http:"!==e.protocol)throw OPE("only HTTP and HTTPS requests are allowed",REQUEST_PROTOCOL_FORBIDDEN,e)}function validateEndpoint(e,t,s,r){let o;if("string"!=typeof e||!(o=URLParse(e)))throw OPE("authorization server metadata does not contain a valid "+(s?`"as.mtls_endpoint_aliases.${t}"`:`"as.${t}"`),void 0===e?MISSING_SERVER_METADATA:INVALID_SERVER_METADATA,{attribute:s?`mtls_endpoint_aliases.${t}`:t});return checkProtocol(o,r),o}export function resolveEndpoint(e,t,s,r){return s&&e.mtls_endpoint_aliases&&t in e.mtls_endpoint_aliases?validateEndpoint(e.mtls_endpoint_aliases[t],t,s,r):validateEndpoint(e[t],t,s,r)}export async function pushedAuthorizationRequest(e,t,s,r,o){assertAs(e),assertClient(t);const n=resolveEndpoint(e,"pushed_authorization_request_endpoint",t.use_mtls_endpoint_aliases,!0!==o?.[allowInsecureRequests]),a=new URLSearchParams(r);a.set("client_id",t.client_id);const i=prepareHeaders(o?.headers);i.set("accept","application/json"),void 0!==o?.DPoP&&(assertDPoP(o.DPoP),await o.DPoP.addProof(n,i,"POST"));const c=await authenticatedRequest(e,t,s,n,a,i,o);return o?.DPoP?.cacheNonce(c),c}class DPoPHandler{#e;#t;#s;#r;#o;#n;#a;constructor(e,t,s){if(assertPrivateKey(t?.privateKey,'"DPoP.privateKey"'),assertPublicKey(t?.publicKey,'"DPoP.publicKey"'),!t.publicKey.extractable)throw CodedTypeError('"DPoP.publicKey.extractable" must be true',ERR_INVALID_ARG_VALUE);this.#o=s?.[modifyAssertion],this.#r=getClockSkew(e),this.#t=t.privateKey,this.#s=t.publicKey,branded.add(this)}#i(e){this.#n||=new Map;let t=this.#n.get(e);return t&&(this.#n.delete(e),this.#n.set(e,t)),t}#c(e,t){this.#n||=new Map,this.#n.delete(e),100===this.#n.size&&this.#n.delete(this.#n.keys().next().value),this.#n.set(e,t)}async calculateThumbprint(){if(!this.#a){const e=await crypto.subtle.exportKey("jwk",this.#s);let t;switch(e.kty){case"EC":t={crv:e.crv,kty:e.kty,x:e.x,y:e.y};break;case"OKP":t={crv:e.crv,kty:e.kty,x:e.x};break;case"RSA":t={e:e.e,kty:e.kty,n:e.n};break;default:throw new UnsupportedOperationError("unsupported JWK",{cause:{jwk:e}})}this.#a||=b64u(await crypto.subtle.digest({name:"SHA-256"},buf(JSON.stringify(t))))}return this.#a}async addProof(e,t,s,r){this.#e||={alg:keyToJws(this.#t),typ:"dpop+jwt",jwk:await publicJwk(this.#s)};const o=this.#i(e.origin),n={iat:epochTime()+this.#r,jti:randomBytes(),htm:s,nonce:o,htu:`${e.origin}${e.pathname}`,ath:r?b64u(await crypto.subtle.digest("SHA-256",buf(r))):void 0};this.#o?.(this.#e,n),t.set("dpop",await signJwt(this.#e,n,this.#t))}cacheNonce(e){try{const t=e.headers.get("dpop-nonce");t&&this.#c(new URL(e.url).origin,t)}catch{}}}export function isDPoPNonceError(e){if(e instanceof WWWAuthenticateChallengeError){const{0:t,length:s}=e.cause;return 1===s&&"dpop"===t.scheme&&"use_dpop_nonce"===t.parameters.error}return e instanceof ResponseBodyError&&"use_dpop_nonce"===e.error}export function DPoP(e,t,s){return new DPoPHandler(e,t,s)}export class ResponseBodyError extends Error{cause;code;error;status;error_description;response;constructor(e,t){super(e,t),this.name=this.constructor.name,this.code=RESPONSE_BODY_ERROR,this.cause=t.cause,this.error=t.cause.error,this.status=t.response.status,this.error_description=t.cause.error_description,Object.defineProperty(this,"response",{enumerable:!1,value:t.response}),Error.captureStackTrace?.(this,this.constructor)}}export class AuthorizationResponseError extends Error{cause;code;error;error_description;constructor(e,t){super(e,t),this.name=this.constructor.name,this.code=AUTHORIZATION_RESPONSE_ERROR,this.cause=t.cause,this.error=t.cause.get("error"),this.error_description=t.cause.get("error_description")??void 0,Error.captureStackTrace?.(this,this.constructor)}}export class WWWAuthenticateChallengeError extends Error{cause;code;response;status;constructor(e,t){super(e,t),this.name=this.constructor.name,this.code=WWW_AUTHENTICATE_CHALLENGE,this.cause=t.cause,this.status=t.response.status,this.response=t.response,Object.defineProperty(this,"response",{enumerable:!1}),Error.captureStackTrace?.(this,this.constructor)}}const tokenMatch="[a-zA-Z0-9!#$%&\\'\\*\\+\\-\\.\\^_`\\|~]+",token68Match="[a-zA-Z0-9\\-\\._\\~\\+\\/]+[=]{0,2}",quotedMatch='"((?:[^"\\\\]|\\\\.)*)"',quotedParamMatcher="("+tokenMatch+")\\s*=\\s*"+quotedMatch,paramMatcher="("+tokenMatch+")\\s*=\\s*("+tokenMatch+")",schemeRE=new RegExp("^[,\\s]*("+tokenMatch+")\\s(.*)"),quotedParamRE=new RegExp("^[,\\s]*"+quotedParamMatcher+"[,\\s]*(.*)"),unquotedParamRE=new RegExp("^[,\\s]*"+paramMatcher+"[,\\s]*(.*)"),token68ParamRE=new RegExp("^("+token68Match+")(?:$|[,\\s])(.*)");function parseWwwAuthenticateChallenges(e){if(!looseInstanceOf(e,Response))throw CodedTypeError('"response" must be an instance of Response',ERR_INVALID_ARG_TYPE);const t=e.headers.get("www-authenticate");if(null===t)return;const s=[];let r=t;for(;r;){let e=r.match(schemeRE);const t=e?.[1].toLowerCase();if(r=e?.[2],!t)return;const o={};let n;for(;r;){let t,s;if(e=r.match(quotedParamRE)){if([,t,s,r]=e,s.includes("\\"))try{s=JSON.parse(`"${s}"`)}catch{}o[t.toLowerCase()]=s}else{if(!(e=r.match(unquotedParamRE))){if(e=r.match(token68ParamRE)){if(Object.keys(o).length)break;[,n,r]=e;break}return}[,t,s,r]=e,o[t.toLowerCase()]=s}}const a={scheme:t,parameters:o};n&&(a.token68=n),s.push(a)}return s.length?s:void 0}export async function processPushedAuthorizationResponse(e,t,s){if(assertAs(e),assertClient(t),!looseInstanceOf(s,Response))throw CodedTypeError('"response" must be an instance of Response',ERR_INVALID_ARG_TYPE);checkAuthenticationChallenges(s),await checkOAuthBodyError(s,201,"Pushed Authorization Request Endpoint"),assertReadableResponse(s);const r=await getResponseJsonBody(s);assertString(r.request_uri,'"response" body "request_uri" property',INVALID_RESPONSE,{body:r});let o="number"!=typeof r.expires_in?parseFloat(r.expires_in):r.expires_in;return assertNumber(o,!0,'"response" body "expires_in" property',INVALID_RESPONSE,{body:r}),r.expires_in=o,r}async function parseOAuthResponseErrorBody(e){if(e.status>399&&e.status<500){assertReadableResponse(e),assertApplicationJson(e);try{const t=await e.clone().json();if(isJsonObject(t)&&"string"==typeof t.error&&t.error.length)return t}catch{}}}async function checkOAuthBodyError(e,t,s){if(e.status!==t){let t;if(t=await parseOAuthResponseErrorBody(e))throw await(e.body?.cancel()),new ResponseBodyError("server responded with an error in the response body",{cause:t,response:e});throw OPE(`"response" is not a conform ${s} response (unexpected HTTP status code)`,RESPONSE_IS_NOT_CONFORM,e)}}function assertDPoP(e){if(!branded.has(e))throw CodedTypeError('"options.DPoP" is not a valid DPoPHandle',ERR_INVALID_ARG_VALUE)}async function resourceRequest(e,t,s,r,o,n){if(assertString(e,'"accessToken"'),!(s instanceof URL))throw CodedTypeError('"url" must be an instance of URL',ERR_INVALID_ARG_TYPE);checkProtocol(s,!0!==n?.[allowInsecureRequests]),r=prepareHeaders(r),n?.DPoP&&(assertDPoP(n.DPoP),await n.DPoP.addProof(s,r,t.toUpperCase(),e)),r.set("authorization",`${r.has("dpop")?"DPoP":"Bearer"} ${e}`);const a=await(n?.[customFetch]||fetch)(s.href,{body:o,headers:Object.fromEntries(r.entries()),method:t,redirect:"manual",signal:signal(s,n?.signal)});return n?.DPoP?.cacheNonce(a),a}export async function protectedResourceRequest(e,t,s,r,o,n){const a=await resourceRequest(e,t,s,r,o,n);return checkAuthenticationChallenges(a),a}export async function userInfoRequest(e,t,s,r){assertAs(e),assertClient(t);const o=resolveEndpoint(e,"userinfo_endpoint",t.use_mtls_endpoint_aliases,!0!==r?.[allowInsecureRequests]),n=prepareHeaders(r?.headers);return t.userinfo_signed_response_alg?n.set("accept","application/jwt"):(n.set("accept","application/json"),n.append("accept","application/jwt")),resourceRequest(s,"GET",o,n,null,{...r,[clockSkew]:getClockSkew(t)})}let jwksMap;function setJwksCache(e,t,s,r){jwksMap||=new WeakMap,jwksMap.set(e,{jwks:t,uat:s,get age(){return epochTime()-this.uat}}),r&&Object.assign(r,{jwks:structuredClone(t),uat:s})}function isFreshJwksCache(e){return"object"==typeof e&&null!==e&&("uat"in e&&"number"==typeof e.uat&&!(epochTime()-e.uat>=300)&&!!("jwks"in e&&isJsonObject(e.jwks)&&Array.isArray(e.jwks.keys)&&Array.prototype.every.call(e.jwks.keys,isJsonObject)))}function clearJwksCache(e,t){jwksMap?.delete(e),delete t?.jwks,delete t?.uat}async function getPublicSigKeyFromIssuerJwksUri(e,t,s){const{alg:r,kid:o}=s;let n,a,i;if(checkSupportedJwsAlg(s),!jwksMap?.has(e)&&isFreshJwksCache(t?.[jwksCache])&&setJwksCache(e,t?.[jwksCache].jwks,t?.[jwksCache].uat),jwksMap?.has(e)){if(({jwks:n,age:a}=jwksMap.get(e)),a>=300)return clearJwksCache(e,t?.[jwksCache]),getPublicSigKeyFromIssuerJwksUri(e,t,s)}else n=await jwksRequest(e,t).then(processJwksResponse),a=0,setJwksCache(e,n,epochTime(),t?.[jwksCache]);switch(r.slice(0,2)){case"RS":case"PS":i="RSA";break;case"ES":i="EC";break;case"Ed":i="OKP";break;default:throw new UnsupportedOperationError("unsupported JWS algorithm",{cause:{alg:r}})}const c=n.keys.filter((e=>{if(e.kty!==i)return!1;if(void 0!==o&&o!==e.kid)return!1;if(void 0!==e.alg&&r!==e.alg)return!1;if(void 0!==e.use&&"sig"!==e.use)return!1;if(!1===e.key_ops?.includes("verify"))return!1;switch(!0){case"ES256"===r&&"P-256"!==e.crv:case"ES384"===r&&"P-384"!==e.crv:case"ES512"===r&&"P-521"!==e.crv:case"Ed25519"===r&&"Ed25519"!==e.crv:case"EdDSA"===r&&"Ed25519"!==e.crv:return!1}return!0})),{0:p,length:u}=c;if(!u){if(a>=60)return clearJwksCache(e,t?.[jwksCache]),getPublicSigKeyFromIssuerJwksUri(e,t,s);throw OPE("error when selecting a JWT verification key, no applicable keys found",KEY_SELECTION,{header:s,candidates:c,jwks_uri:new URL(e.jwks_uri)})}if(1!==u)throw OPE('error when selecting a JWT verification key, multiple applicable keys found, a "kid" JWT Header Parameter is required',KEY_SELECTION,{header:s,candidates:c,jwks_uri:new URL(e.jwks_uri)});return importJwk(r,p)}export const skipSubjectCheck=Symbol();export function getContentType(e){return e.headers.get("content-type")?.split(";")[0]}export async function processUserInfoResponse(e,t,s,r,o){if(assertAs(e),assertClient(t),!looseInstanceOf(r,Response))throw CodedTypeError('"response" must be an instance of Response',ERR_INVALID_ARG_TYPE);if(checkAuthenticationChallenges(r),200!==r.status)throw OPE('"response" is not a conform UserInfo Endpoint response (unexpected HTTP status code)',RESPONSE_IS_NOT_CONFORM,r);let n;if(assertReadableResponse(r),"application/jwt"===getContentType(r)){const{claims:s,jwt:a}=await validateJwt(await r.text(),checkSigningAlgorithm.bind(void 0,t.userinfo_signed_response_alg,e.userinfo_signing_alg_values_supported,void 0),getClockSkew(t),getClockTolerance(t),o?.[jweDecrypt]).then(validateOptionalAudience.bind(void 0,t.client_id)).then(validateOptionalIssuer.bind(void 0,e));jwtRefs.set(r,a),n=s}else{if(t.userinfo_signed_response_alg)throw OPE("JWT UserInfo Response expected",JWT_USERINFO_EXPECTED,r);n=await getResponseJsonBody(r)}if(assertString(n.sub,'"response" body "sub" property',INVALID_RESPONSE,{body:n}),s===skipSubjectCheck);else if(assertString(s,'"expectedSubject"'),n.sub!==s)throw OPE('unexpected "response" body "sub" property value',JSON_ATTRIBUTE_COMPARISON,{expected:s,body:n,attribute:"sub"});return n}async function authenticatedRequest(e,t,s,r,o,n,a){return await s(e,t,o,n),n.set("content-type","application/x-www-form-urlencoded;charset=UTF-8"),(a?.[customFetch]||fetch)(r.href,{body:o,headers:Object.fromEntries(n.entries()),method:"POST",redirect:"manual",signal:signal(r,a?.signal)})}async function tokenEndpointRequest(e,t,s,r,o,n){const a=resolveEndpoint(e,"token_endpoint",t.use_mtls_endpoint_aliases,!0!==n?.[allowInsecureRequests]);o.set("grant_type",r);const i=prepareHeaders(n?.headers);i.set("accept","application/json"),void 0!==n?.DPoP&&(assertDPoP(n.DPoP),await n.DPoP.addProof(a,i,"POST"));const c=await authenticatedRequest(e,t,s,a,o,i,n);return n?.DPoP?.cacheNonce(c),c}export async function refreshTokenGrantRequest(e,t,s,r,o){assertAs(e),assertClient(t),assertString(r,'"refreshToken"');const n=new URLSearchParams(o?.additionalParameters);return n.set("refresh_token",r),tokenEndpointRequest(e,t,s,"refresh_token",n,o)}const idTokenClaims=new WeakMap,jwtRefs=new WeakMap;export function getValidatedIdTokenClaims(e){if(!e.id_token)return;const t=idTokenClaims.get(e);if(!t)throw CodedTypeError('"ref" was already garbage collected or did not resolve from the proper sources',ERR_INVALID_ARG_VALUE);return t}export async function validateApplicationLevelSignature(e,t,s){if(assertAs(e),!jwtRefs.has(t))throw CodedTypeError('"ref" does not contain a processed JWT Response to verify the signature of',ERR_INVALID_ARG_VALUE);const{0:r,1:o,2:n}=jwtRefs.get(t).split("."),a=JSON.parse(buf(b64u(r)));if(a.alg.startsWith("HS"))throw new UnsupportedOperationError("unsupported JWS algorithm",{cause:{alg:a.alg}});let i;i=await getPublicSigKeyFromIssuerJwksUri(e,s,a),await validateJwsSignature(r,o,i,b64u(n))}async function processGenericAccessTokenResponse(e,t,s,r,o){if(assertAs(e),assertClient(t),!looseInstanceOf(s,Response))throw CodedTypeError('"response" must be an instance of Response',ERR_INVALID_ARG_TYPE);checkAuthenticationChallenges(s),await checkOAuthBodyError(s,200,"Token Endpoint"),assertReadableResponse(s);const n=await getResponseJsonBody(s);if(assertString(n.access_token,'"response" body "access_token" property',INVALID_RESPONSE,{body:n}),assertString(n.token_type,'"response" body "token_type" property',INVALID_RESPONSE,{body:n}),n.token_type=n.token_type.toLowerCase(),"dpop"!==n.token_type&&"bearer"!==n.token_type)throw new UnsupportedOperationError("unsupported `token_type` value",{cause:{body:n}});if(void 0!==n.expires_in){let e="number"!=typeof n.expires_in?parseFloat(n.expires_in):n.expires_in;assertNumber(e,!0,'"response" body "expires_in" property',INVALID_RESPONSE,{body:n}),n.expires_in=e}if(void 0!==n.refresh_token&&assertString(n.refresh_token,'"response" body "refresh_token" property',INVALID_RESPONSE,{body:n}),void 0!==n.scope&&"string"!=typeof n.scope)throw OPE('"response" body "scope" property must be a string',INVALID_RESPONSE,{body:n});if(void 0!==n.id_token){assertString(n.id_token,'"response" body "id_token" property',INVALID_RESPONSE,{body:n});const a=["aud","exp","iat","iss","sub"];!0===t.require_auth_time&&a.push("auth_time"),void 0!==t.default_max_age&&(assertNumber(t.default_max_age,!0,'"client.default_max_age"'),a.push("auth_time")),r?.length&&a.push(...r);const{claims:i,jwt:c}=await validateJwt(n.id_token,checkSigningAlgorithm.bind(void 0,t.id_token_signed_response_alg,e.id_token_signing_alg_values_supported,"RS256"),getClockSkew(t),getClockTolerance(t),o?.[jweDecrypt]).then(validatePresence.bind(void 0,a)).then(validateIssuer.bind(void 0,e)).then(validateAudience.bind(void 0,t.client_id));if(Array.isArray(i.aud)&&1!==i.aud.length){if(void 0===i.azp)throw OPE('ID Token "aud" (audience) claim includes additional untrusted audiences',JWT_CLAIM_COMPARISON,{claims:i,claim:"aud"});if(i.azp!==t.client_id)throw OPE('unexpected ID Token "azp" (authorized party) claim value',JWT_CLAIM_COMPARISON,{expected:t.client_id,claims:i,claim:"azp"})}void 0!==i.auth_time&&assertNumber(i.auth_time,!1,'ID Token "auth_time" (authentication time)',INVALID_RESPONSE,{claims:i}),jwtRefs.set(s,c),idTokenClaims.set(n,i)}return n}function checkAuthenticationChallenges(e){let t;if(t=parseWwwAuthenticateChallenges(e))throw new WWWAuthenticateChallengeError("server responded with a challenge in the WWW-Authenticate HTTP Header",{cause:t,response:e})}export async function processRefreshTokenResponse(e,t,s,r){return processGenericAccessTokenResponse(e,t,s,void 0,r)}function validateOptionalAudience(e,t){return void 0!==t.claims.aud?validateAudience(e,t):t}function validateAudience(e,t){if(Array.isArray(t.claims.aud)){if(!t.claims.aud.includes(e))throw OPE('unexpected JWT "aud" (audience) claim value',JWT_CLAIM_COMPARISON,{expected:e,claims:t.claims,claim:"aud"})}else if(t.claims.aud!==e)throw OPE('unexpected JWT "aud" (audience) claim value',JWT_CLAIM_COMPARISON,{expected:e,claims:t.claims,claim:"aud"});return t}function validateOptionalIssuer(e,t){return void 0!==t.claims.iss?validateIssuer(e,t):t}function validateIssuer(e,t){const s=e[_expectedIssuer]?.(t)??e.issuer;if(t.claims.iss!==s)throw OPE('unexpected JWT "iss" (issuer) claim value',JWT_CLAIM_COMPARISON,{expected:s,claims:t.claims,claim:"iss"});return t}const branded=new WeakSet;function brand(e){return branded.add(e),e}export const nopkce=Symbol();export async function authorizationCodeGrantRequest(e,t,s,r,o,n,a){if(assertAs(e),assertClient(t),!branded.has(r))throw CodedTypeError('"callbackParameters" must be an instance of URLSearchParams obtained from "validateAuthResponse()", or "validateJwtAuthResponse()',ERR_INVALID_ARG_VALUE);assertString(o,'"redirectUri"');const i=getURLSearchParameter(r,"code");if(!i)throw OPE('no authorization code in "callbackParameters"',INVALID_RESPONSE);const c=new URLSearchParams(a?.additionalParameters);return c.set("redirect_uri",o),c.set("code",i),n!==nopkce&&(assertString(n,'"codeVerifier"'),c.set("code_verifier",n)),tokenEndpointRequest(e,t,s,"authorization_code",c,a)}const jwtClaimNames={aud:"audience",c_hash:"code hash",client_id:"client id",exp:"expiration time",iat:"issued at",iss:"issuer",jti:"jwt id",nonce:"nonce",s_hash:"state hash",sub:"subject",ath:"access token hash",htm:"http method",htu:"http uri",cnf:"confirmation",auth_time:"authentication time"};function validatePresence(e,t){for(const s of e)if(void 0===t.claims[s])throw OPE(`JWT "${s}" (${jwtClaimNames[s]}) claim missing`,INVALID_RESPONSE,{claims:t.claims});return t}export const expectNoNonce=Symbol();export const skipAuthTimeCheck=Symbol();export async function processAuthorizationCodeResponse(e,t,s,r){return"string"==typeof r?.expectedNonce||"number"==typeof r?.maxAge||r?.requireIdToken?processAuthorizationCodeOpenIDResponse(e,t,s,r.expectedNonce,r.maxAge,{[jweDecrypt]:r[jweDecrypt]}):processAuthorizationCodeOAuth2Response(e,t,s,r)}async function processAuthorizationCodeOpenIDResponse(e,t,s,r,o,n){const a=[];switch(r){case void 0:r=expectNoNonce;break;case expectNoNonce:break;default:assertString(r,'"expectedNonce" argument'),a.push("nonce")}switch(o??=t.default_max_age,o){case void 0:o=skipAuthTimeCheck;break;case skipAuthTimeCheck:break;default:assertNumber(o,!0,'"maxAge" argument'),a.push("auth_time")}const i=await processGenericAccessTokenResponse(e,t,s,a,n);assertString(i.id_token,'"response" body "id_token" property',INVALID_RESPONSE,{body:i});const c=getValidatedIdTokenClaims(i);if(o!==skipAuthTimeCheck){const e=epochTime()+getClockSkew(t),s=getClockTolerance(t);if(c.auth_time+o<e-s)throw OPE("too much time has elapsed since the last End-User authentication",JWT_TIMESTAMP_CHECK,{claims:c,now:e,tolerance:s,claim:"auth_time"})}if(r===expectNoNonce){if(void 0!==c.nonce)throw OPE('unexpected ID Token "nonce" claim value',JWT_CLAIM_COMPARISON,{expected:void 0,claims:c,claim:"nonce"})}else if(c.nonce!==r)throw OPE('unexpected ID Token "nonce" claim value',JWT_CLAIM_COMPARISON,{expected:r,claims:c,claim:"nonce"});return i}async function processAuthorizationCodeOAuth2Response(e,t,s,r){const o=await processGenericAccessTokenResponse(e,t,s,void 0,r),n=getValidatedIdTokenClaims(o);if(n){if(void 0!==t.default_max_age){assertNumber(t.default_max_age,!0,'"client.default_max_age"');const e=epochTime()+getClockSkew(t),s=getClockTolerance(t);if(n.auth_time+t.default_max_age<e-s)throw OPE("too much time has elapsed since the last End-User authentication",JWT_TIMESTAMP_CHECK,{claims:n,now:e,tolerance:s,claim:"auth_time"})}if(void 0!==n.nonce)throw OPE('unexpected ID Token "nonce" claim value',JWT_CLAIM_COMPARISON,{expected:void 0,claims:n,claim:"nonce"})}return o}export const WWW_AUTHENTICATE_CHALLENGE="OAUTH_WWW_AUTHENTICATE_CHALLENGE";export const RESPONSE_BODY_ERROR="OAUTH_RESPONSE_BODY_ERROR";export const UNSUPPORTED_OPERATION="OAUTH_UNSUPPORTED_OPERATION";export const AUTHORIZATION_RESPONSE_ERROR="OAUTH_AUTHORIZATION_RESPONSE_ERROR";export const JWT_USERINFO_EXPECTED="OAUTH_JWT_USERINFO_EXPECTED";export const PARSE_ERROR="OAUTH_PARSE_ERROR";export const INVALID_RESPONSE="OAUTH_INVALID_RESPONSE";export const INVALID_REQUEST="OAUTH_INVALID_REQUEST";export const RESPONSE_IS_NOT_JSON="OAUTH_RESPONSE_IS_NOT_JSON";export const RESPONSE_IS_NOT_CONFORM="OAUTH_RESPONSE_IS_NOT_CONFORM";export const HTTP_REQUEST_FORBIDDEN="OAUTH_HTTP_REQUEST_FORBIDDEN";export const REQUEST_PROTOCOL_FORBIDDEN="OAUTH_REQUEST_PROTOCOL_FORBIDDEN";export const JWT_TIMESTAMP_CHECK="OAUTH_JWT_TIMESTAMP_CHECK_FAILED";export const JWT_CLAIM_COMPARISON="OAUTH_JWT_CLAIM_COMPARISON_FAILED";export const JSON_ATTRIBUTE_COMPARISON="OAUTH_JSON_ATTRIBUTE_COMPARISON_FAILED";export const KEY_SELECTION="OAUTH_KEY_SELECTION_FAILED";export const MISSING_SERVER_METADATA="OAUTH_MISSING_SERVER_METADATA";export const INVALID_SERVER_METADATA="OAUTH_INVALID_SERVER_METADATA";function checkJwtType(e,t){if("string"!=typeof t.header.typ||normalizeTyp(t.header.typ)!==e)throw OPE('unexpected JWT "typ" header parameter value',INVALID_RESPONSE,{header:t.header});return t}export async function clientCredentialsGrantRequest(e,t,s,r,o){return assertAs(e),assertClient(t),tokenEndpointRequest(e,t,s,"client_credentials",new URLSearchParams(r),o)}export async function genericTokenEndpointRequest(e,t,s,r,o,n){return assertAs(e),assertClient(t),assertString(r,'"grantType"'),tokenEndpointRequest(e,t,s,r,new URLSearchParams(o),n)}export async function processGenericTokenEndpointResponse(e,t,s,r){return processGenericAccessTokenResponse(e,t,s,void 0,r)}export async function processClientCredentialsResponse(e,t,s,r){return processGenericAccessTokenResponse(e,t,s,void 0,r)}export async function revocationRequest(e,t,s,r,o){assertAs(e),assertClient(t),assertString(r,'"token"');const n=resolveEndpoint(e,"revocation_endpoint",t.use_mtls_endpoint_aliases,!0!==o?.[allowInsecureRequests]),a=new URLSearchParams(o?.additionalParameters);a.set("token",r);const i=prepareHeaders(o?.headers);return i.delete("accept"),authenticatedRequest(e,t,s,n,a,i,o)}export async function processRevocationResponse(e){if(!looseInstanceOf(e,Response))throw CodedTypeError('"response" must be an instance of Response',ERR_INVALID_ARG_TYPE);checkAuthenticationChallenges(e),await checkOAuthBodyError(e,200,"Revocation Endpoint")}function assertReadableResponse(e){if(e.bodyUsed)throw CodedTypeError('"response" body has been used already',ERR_INVALID_ARG_VALUE)}export async function introspectionRequest(e,t,s,r,o){assertAs(e),assertClient(t),assertString(r,'"token"');const n=resolveEndpoint(e,"introspection_endpoint",t.use_mtls_endpoint_aliases,!0!==o?.[allowInsecureRequests]),a=new URLSearchParams(o?.additionalParameters);a.set("token",r);const i=prepareHeaders(o?.headers);return o?.requestJwtResponse??t.introspection_signed_response_alg?i.set("accept","application/token-introspection+jwt"):i.set("accept","application/json"),authenticatedRequest(e,t,s,n,a,i,o)}export async function processIntrospectionResponse(e,t,s,r){if(assertAs(e),assertClient(t),!looseInstanceOf(s,Response))throw CodedTypeError('"response" must be an instance of Response',ERR_INVALID_ARG_TYPE);let o;if(checkAuthenticationChallenges(s),await checkOAuthBodyError(s,200,"Introspection Endpoint"),"application/token-introspection+jwt"===getContentType(s)){assertReadableResponse(s);const{claims:n,jwt:a}=await validateJwt(await s.text(),checkSigningAlgorithm.bind(void 0,t.introspection_signed_response_alg,e.introspection_signing_alg_values_supported,"RS256"),getClockSkew(t),getClockTolerance(t),r?.[jweDecrypt]).then(checkJwtType.bind(void 0,"token-introspection+jwt")).then(validatePresence.bind(void 0,["aud","iat","iss"])).then(validateIssuer.bind(void 0,e)).then(validateAudience.bind(void 0,t.client_id));if(jwtRefs.set(s,a),!isJsonObject(n.token_introspection))throw OPE('JWT "token_introspection" claim must be a JSON object',INVALID_RESPONSE,{claims:n});o=n.token_introspection}else assertReadableResponse(s),o=await getResponseJsonBody(s);if("boolean"!=typeof o.active)throw OPE('"response" body "active" property must be a boolean',INVALID_RESPONSE,{body:o});return o}async function jwksRequest(e,t){assertAs(e);const s=resolveEndpoint(e,"jwks_uri",!1,!0!==t?.[allowInsecureRequests]),r=prepareHeaders(t?.headers);return r.set("accept","application/json"),r.append("accept","application/jwk-set+json"),(t?.[customFetch]||fetch)(s.href,{body:void 0,headers:Object.fromEntries(r.entries()),method:"GET",redirect:"manual",signal:signal(s,t?.signal)})}async function processJwksResponse(e){if(!looseInstanceOf(e,Response))throw CodedTypeError('"response" must be an instance of Response',ERR_INVALID_ARG_TYPE);if(200!==e.status)throw OPE('"response" is not a conform JSON Web Key Set response (unexpected HTTP status code)',RESPONSE_IS_NOT_CONFORM,e);assertReadableResponse(e);const t=await getResponseJsonBody(e,(e=>assertContentTypes(e,"application/json","application/jwk-set+json")));if(!Array.isArray(t.keys))throw OPE('"response" body "keys" property must be an array',INVALID_RESPONSE,{body:t});if(!Array.prototype.every.call(t.keys,isJsonObject))throw OPE('"response" body "keys" property members must be JWK formatted objects',INVALID_RESPONSE,{body:t});return t}function supported(e){switch(e){case"PS256":case"ES256":case"RS256":case"PS384":case"ES384":case"RS384":case"PS512":case"ES512":case"RS512":case"Ed25519":case"EdDSA":return!0;default:return!1}}function checkSupportedJwsAlg(e){if(!supported(e.alg))throw new UnsupportedOperationError('unsupported JWS "alg" identifier',{cause:{alg:e.alg}})}function checkRsaKeyAlgorithm(e){const{algorithm:t}=e;if("number"!=typeof t.modulusLength||t.modulusLength<2048)throw new UnsupportedOperationError(`unsupported ${t.name} modulusLength`,{cause:e})}function ecdsaHashName(e){const{algorithm:t}=e;switch(t.namedCurve){case"P-256":return"SHA-256";case"P-384":return"SHA-384";case"P-521":return"SHA-512";default:throw new UnsupportedOperationError("unsupported ECDSA namedCurve",{cause:e})}}function keyToSubtle(e){switch(e.algorithm.name){case"ECDSA":return{name:e.algorithm.name,hash:ecdsaHashName(e)};case"RSA-PSS":switch(checkRsaKeyAlgorithm(e),e.algorithm.hash.name){case"SHA-256":case"SHA-384":case"SHA-512":return{name:e.algorithm.name,saltLength:parseInt(e.algorithm.hash.name.slice(-3),10)>>3};default:throw new UnsupportedOperationError("unsupported RSA-PSS hash name",{cause:e})}case"RSASSA-PKCS1-v1_5":return checkRsaKeyAlgorithm(e),e.algorithm.name;case"Ed25519":return e.algorithm.name}throw new UnsupportedOperationError("unsupported CryptoKey algorithm name",{cause:e})}async function validateJwsSignature(e,t,s,r){const o=buf(`${e}.${t}`),n=keyToSubtle(s);if(!await crypto.subtle.verify(n,s,r,o))throw OPE("JWT signature verification failed",INVALID_RESPONSE,{key:s,data:o,signature:r,algorithm:n})}async function validateJwt(e,t,s,r,o){let n,a,{0:i,1:c,length:p}=e.split(".");if(5===p){if(void 0===o)throw new UnsupportedOperationError("JWE decryption is not configured",{cause:e});e=await o(e),({0:i,1:c,length:p}=e.split("."))}if(3!==p)throw OPE("Invalid JWT",INVALID_RESPONSE,e);try{n=JSON.parse(buf(b64u(i)))}catch(e){throw OPE("failed to parse JWT Header body as base64url encoded JSON",PARSE_ERROR,e)}if(!isJsonObject(n))throw OPE("JWT Header must be a top level object",INVALID_RESPONSE,e);if(t(n),void 0!==n.crit)throw new UnsupportedOperationError('no JWT "crit" header parameter extensions are supported',{cause:{header:n}});try{a=JSON.parse(buf(b64u(c)))}catch(e){throw OPE("failed to parse JWT Payload body as base64url encoded JSON",PARSE_ERROR,e)}if(!isJsonObject(a))throw OPE("JWT Payload must be a top level object",INVALID_RESPONSE,e);const u=epochTime()+s;if(void 0!==a.exp){if("number"!=typeof a.exp)throw OPE('unexpected JWT "exp" (expiration time) claim type',INVALID_RESPONSE,{claims:a});if(a.exp<=u-r)throw OPE('unexpected JWT "exp" (expiration time) claim value, expiration is past current timestamp',JWT_TIMESTAMP_CHECK,{claims:a,now:u,tolerance:r,claim:"exp"})}if(void 0!==a.iat&&"number"!=typeof a.iat)throw OPE('unexpected JWT "iat" (issued at) claim type',INVALID_RESPONSE,{claims:a});if(void 0!==a.iss&&"string"!=typeof a.iss)throw OPE('unexpected JWT "iss" (issuer) claim type',INVALID_RESPONSE,{claims:a});if(void 0!==a.nbf){if("number"!=typeof a.nbf)throw OPE('unexpected JWT "nbf" (not before) claim type',INVALID_RESPONSE,{claims:a});if(a.nbf>u+r)throw OPE('unexpected JWT "nbf" (not before) claim value',JWT_TIMESTAMP_CHECK,{claims:a,now:u,tolerance:r,claim:"nbf"})}if(void 0!==a.aud&&"string"!=typeof a.aud&&!Array.isArray(a.aud))throw OPE('unexpected JWT "aud" (audience) claim type',INVALID_RESPONSE,{claims:a});return{header:n,claims:a,jwt:e}}export async function validateJwtAuthResponse(e,t,s,r,o){if(assertAs(e),assertClient(t),s instanceof URL&&(s=s.searchParams),!(s instanceof URLSearchParams))throw CodedTypeError('"parameters" must be an instance of URLSearchParams, or URL',ERR_INVALID_ARG_TYPE);const n=getURLSearchParameter(s,"response");if(!n)throw OPE('"parameters" does not contain a JARM response',INVALID_RESPONSE);const{claims:a,header:i,jwt:c}=await validateJwt(n,checkSigningAlgorithm.bind(void 0,t.authorization_signed_response_alg,e.authorization_signing_alg_values_supported,"RS256"),getClockSkew(t),getClockTolerance(t),o?.[jweDecrypt]).then(validatePresence.bind(void 0,["aud","exp","iss"])).then(validateIssuer.bind(void 0,e)).then(validateAudience.bind(void 0,t.client_id)),{0:p,1:u,2:d}=c.split("."),l=b64u(d),h=await getPublicSigKeyFromIssuerJwksUri(e,o,i);await validateJwsSignature(p,u,h,l);const _=new URLSearchParams;for(const[e,t]of Object.entries(a))"string"==typeof t&&"aud"!==e&&_.set(e,t);return validateAuthResponse(e,t,_,r)}async function idTokenHash(e,t,s){let r;switch(t.alg){case"RS256":case"PS256":case"ES256":r="SHA-256";break;case"RS384":case"PS384":case"ES384":r="SHA-384";break;case"RS512":case"PS512":case"ES512":case"Ed25519":case"EdDSA":r="SHA-512";break;default:throw new UnsupportedOperationError(`unsupported JWS algorithm for ${s} calculation`,{cause:{alg:t.alg}})}const o=await crypto.subtle.digest(r,buf(e));return b64u(o.slice(0,o.byteLength/2))}async function idTokenHashMatches(e,t,s,r){return t===await idTokenHash(e,s,r)}export async function validateDetachedSignatureResponse(e,t,s,r,o,n,a){return validateHybridResponse(e,t,s,r,o,n,a,!0)}export async function validateCodeIdTokenResponse(e,t,s,r,o,n,a){return validateHybridResponse(e,t,s,r,o,n,a,!1)}async function consumeStream(e){if(e.bodyUsed)throw CodedTypeError("form_post Request instances must contain a readable body",ERR_INVALID_ARG_VALUE,{cause:e});return e.text()}export async function formPostResponse(e){if("POST"!==e.method)throw CodedTypeError("form_post responses are expected to use the POST method",ERR_INVALID_ARG_VALUE,{cause:e});if("application/x-www-form-urlencoded"!==getContentType(e))throw CodedTypeError("form_post responses are expected to use the application/x-www-form-urlencoded content-type",ERR_INVALID_ARG_VALUE,{cause:e});return consumeStream(e)}async function validateHybridResponse(e,t,s,r,o,n,a,i){if(assertAs(e),assertClient(t),s instanceof URL){if(!s.hash.length)throw CodedTypeError('"parameters" as an instance of URL must contain a hash (fragment) with the Authorization Response parameters',ERR_INVALID_ARG_VALUE);s=new URLSearchParams(s.hash.slice(1))}else if(looseInstanceOf(s,Request))s=new URLSearchParams(await formPostResponse(s));else{if(!(s instanceof URLSearchParams))throw CodedTypeError('"parameters" must be an instance of URLSearchParams, URL, or Response',ERR_INVALID_ARG_TYPE);s=new URLSearchParams(s)}const c=getURLSearchParameter(s,"id_token");switch(s.delete("id_token"),o){case void 0:case expectNoState:break;default:assertString(o,'"expectedState" argument')}const p=validateAuthResponse({...e,authorization_response_iss_parameter_supported:!1},t,s,o);if(!c)throw OPE('"parameters" does not contain an ID Token',INVALID_RESPONSE);const u=getURLSearchParameter(s,"code");if(!u)throw OPE('"parameters" does not contain an Authorization Code',INVALID_RESPONSE);const d=["aud","exp","iat","iss","sub","nonce","c_hash"],l=s.get("state");!i||"string"!=typeof o&&null===l||d.push("s_hash"),void 0!==n?assertNumber(n,!0,'"maxAge" argument'):void 0!==t.default_max_age&&assertNumber(t.default_max_age,!0,'"client.default_max_age"'),n??=t.default_max_age??skipAuthTimeCheck,(t.require_auth_time||n!==skipAuthTimeCheck)&&d.push("auth_time");const{claims:h,header:_,jwt:E}=await validateJwt(c,checkSigningAlgorithm.bind(void 0,t.id_token_signed_response_alg,e.id_token_signing_alg_values_supported,"RS256"),getClockSkew(t),getClockTolerance(t),a?.[jweDecrypt]).then(validatePresence.bind(void 0,d)).then(validateIssuer.bind(void 0,e)).then(validateAudience.bind(void 0,t.client_id)),m=getClockSkew(t),f=epochTime()+m;if(h.iat<f-3600)throw OPE('unexpected JWT "iat" (issued at) claim value, it is too far in the past',JWT_TIMESTAMP_CHECK,{now:f,claims:h,claim:"iat"});if(assertString(h.c_hash,'ID Token "c_hash" (code hash) claim value',INVALID_RESPONSE,{claims:h}),void 0!==h.auth_time&&assertNumber(h.auth_time,!1,'ID Token "auth_time" (authentication time)',INVALID_RESPONSE,{claims:h}),n!==skipAuthTimeCheck){const e=epochTime()+getClockSkew(t),s=getClockTolerance(t);if(h.auth_time+n<e-s)throw OPE("too much time has elapsed since the last End-User authentication",JWT_TIMESTAMP_CHECK,{claims:h,now:e,tolerance:s,claim:"auth_time"})}if(assertString(r,'"expectedNonce" argument'),h.nonce!==r)throw OPE('unexpected ID Token "nonce" claim value',JWT_CLAIM_COMPARISON,{expected:r,claims:h,claim:"nonce"});if(Array.isArray(h.aud)&&1!==h.aud.length){if(void 0===h.azp)throw OPE('ID Token "aud" (audience) claim includes additional untrusted audiences',JWT_CLAIM_COMPARISON,{claims:h,claim:"aud"});if(h.azp!==t.client_id)throw OPE('unexpected ID Token "azp" (authorized party) claim value',JWT_CLAIM_COMPARISON,{expected:t.client_id,claims:h,claim:"azp"})}const{0:R,1:y,2:S}=E.split("."),A=b64u(S),w=await getPublicSigKeyFromIssuerJwksUri(e,a,_);if(await validateJwsSignature(R,y,w,A),!0!==await idTokenHashMatches(u,h.c_hash,_,"c_hash"))throw OPE('invalid ID Token "c_hash" (code hash) claim value',JWT_CLAIM_COMPARISON,{code:u,alg:_.alg,claim:"c_hash",claims:h});if((i&&null!==l||void 0!==h.s_hash)&&(assertString(h.s_hash,'ID Token "s_hash" (state hash) claim value',INVALID_RESPONSE,{claims:h}),assertString(l,'"state" response parameter',INVALID_RESPONSE,{parameters:s}),!0!==await idTokenHashMatches(l,h.s_hash,_,"s_hash")))throw OPE('invalid ID Token "s_hash" (state hash) claim value',JWT_CLAIM_COMPARISON,{state:l,alg:_.alg,claim:"s_hash",claims:h});return p}function checkSigningAlgorithm(e,t,s,r){if(void 0===e)if(Array.isArray(t)){if(!t.includes(r.alg))throw OPE('unexpected JWT "alg" header parameter',INVALID_RESPONSE,{header:r,expected:t,reason:"authorization server metadata"})}else{if(void 0===s)throw OPE('missing client or server configuration to verify used JWT "alg" header parameter',void 0,{client:e,issuer:t,fallback:s});if("string"==typeof s?r.alg!==s:"function"==typeof s?!s(r.alg):!s.includes(r.alg))throw OPE('unexpected JWT "alg" header parameter',INVALID_RESPONSE,{header:r,expected:s,reason:"default value"})}else if("string"==typeof e?r.alg!==e:!e.includes(r.alg))throw OPE('unexpected JWT "alg" header parameter',INVALID_RESPONSE,{header:r,expected:e,reason:"client configuration"})}function getURLSearchParameter(e,t){const{0:s,length:r}=e.getAll(t);if(r>1)throw OPE(`"${t}" parameter must be provided only once`,INVALID_RESPONSE);return s}export const skipStateCheck=Symbol();export const expectNoState=Symbol();export function validateAuthResponse(e,t,s,r){if(assertAs(e),assertClient(t),s instanceof URL&&(s=s.searchParams),!(s instanceof URLSearchParams))throw CodedTypeError('"parameters" must be an instance of URLSearchParams, or URL',ERR_INVALID_ARG_TYPE);if(getURLSearchParameter(s,"response"))throw OPE('"parameters" contains a JARM response, use validateJwtAuthResponse() instead of validateAuthResponse()',INVALID_RESPONSE,{parameters:s});const o=getURLSearchParameter(s,"iss"),n=getURLSearchParameter(s,"state");if(!o&&e.authorization_response_iss_parameter_supported)throw OPE('response parameter "iss" (issuer) missing',INVALID_RESPONSE,{parameters:s});if(o&&o!==e.issuer)throw OPE('unexpected "iss" (issuer) response parameter value',INVALID_RESPONSE,{expected:e.issuer,parameters:s});switch(r){case void 0:case expectNoState:if(void 0!==n)throw OPE('unexpected "state" response parameter encountered',INVALID_RESPONSE,{expected:void 0,parameters:s});break;case skipStateCheck:break;default:if(assertString(r,'"expectedState" argument'),n!==r)throw OPE(void 0===n?'response parameter "state" missing':'unexpected "state" response parameter value',INVALID_RESPONSE,{expected:r,parameters:s})}if(getURLSearchParameter(s,"error"))throw new AuthorizationResponseError("authorization response from the server is an error",{cause:s});const a=getURLSearchParameter(s,"id_token"),i=getURLSearchParameter(s,"token");if(void 0!==a||void 0!==i)throw new UnsupportedOperationError("implicit and hybrid flows are not supported");return brand(new URLSearchParams(s))}function algToSubtle(e){switch(e){case"PS256":case"PS384":case"PS512":return{name:"RSA-PSS",hash:`SHA-${e.slice(-3)}`};case"RS256":case"RS384":case"RS512":return{name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.slice(-3)}`};case"ES256":case"ES384":return{name:"ECDSA",namedCurve:`P-${e.slice(-3)}`};case"ES512":return{name:"ECDSA",namedCurve:"P-521"};case"Ed25519":case"EdDSA":return"Ed25519";default:throw new UnsupportedOperationError("unsupported JWS algorithm",{cause:{alg:e}})}}async function importJwk(e,t){const{ext:s,key_ops:r,use:o,...n}=t;return crypto.subtle.importKey("jwk",n,algToSubtle(e),!0,["verify"])}export async function deviceAuthorizationRequest(e,t,s,r,o){assertAs(e),assertClient(t);const n=resolveEndpoint(e,"device_authorization_endpoint",t.use_mtls_endpoint_aliases,!0!==o?.[allowInsecureRequests]),a=new URLSearchParams(r);a.set("client_id",t.client_id);const i=prepareHeaders(o?.headers);return i.set("accept","application/json"),authenticatedRequest(e,t,s,n,a,i,o)}export async function processDeviceAuthorizationResponse(e,t,s){if(assertAs(e),assertClient(t),!looseInstanceOf(s,Response))throw CodedTypeError('"response" must be an instance of Response',ERR_INVALID_ARG_TYPE);checkAuthenticationChallenges(s),await checkOAuthBodyError(s,200,"Device Authorization Endpoint"),assertReadableResponse(s);const r=await getResponseJsonBody(s);assertString(r.device_code,'"response" body "device_code" property',INVALID_RESPONSE,{body:r}),assertString(r.user_code,'"response" body "user_code" property',INVALID_RESPONSE,{body:r}),assertString(r.verification_uri,'"response" body "verification_uri" property',INVALID_RESPONSE,{body:r});let o="number"!=typeof r.expires_in?parseFloat(r.expires_in):r.expires_in;return assertNumber(o,!0,'"response" body "expires_in" property',INVALID_RESPONSE,{body:r}),r.expires_in=o,void 0!==r.verification_uri_complete&&assertString(r.verification_uri_complete,'"response" body "verification_uri_complete" property',INVALID_RESPONSE,{body:r}),void 0!==r.interval&&assertNumber(r.interval,!1,'"response" body "interval" property',INVALID_RESPONSE,{body:r}),r}export async function deviceCodeGrantRequest(e,t,s,r,o){assertAs(e),assertClient(t),assertString(r,'"deviceCode"');const n=new URLSearchParams(o?.additionalParameters);return n.set("device_code",r),tokenEndpointRequest(e,t,s,"urn:ietf:params:oauth:grant-type:device_code",n,o)}export async function processDeviceCodeResponse(e,t,s,r){return processGenericAccessTokenResponse(e,t,s,void 0,r)}export async function generateKeyPair(e,t){assertString(e,'"alg"');const s=algToSubtle(e);return(e.startsWith("PS")||e.startsWith("RS"))&&Object.assign(s,{modulusLength:t?.modulusLength??2048,publicExponent:new Uint8Array([1,0,1])}),crypto.subtle.generateKey(s,t?.extractable??!1,["sign","verify"])}function normalizeHtu(e){const t=new URL(e);return t.search="",t.hash="",t.href}async function validateDPoP(e,t,s,r){const o=e.headers.get("dpop");if(null===o)throw OPE("operation indicated DPoP use but the request has no DPoP HTTP Header",INVALID_REQUEST,{headers:e.headers});if(!1===e.headers.get("authorization")?.toLowerCase().startsWith("dpop "))throw OPE("operation indicated DPoP use but the request's Authorization HTTP Header scheme is not DPoP",INVALID_REQUEST,{headers:e.headers});if("string"!=typeof s.cnf?.jkt)throw OPE("operation indicated DPoP use but the JWT Access Token has no jkt confirmation claim",INVALID_REQUEST,{claims:s});const n=getClockSkew(r),a=await validateJwt(o,checkSigningAlgorithm.bind(void 0,r?.signingAlgorithms,void 0,supported),n,getClockTolerance(r),void 0).then(checkJwtType.bind(void 0,"dpop+jwt")).then(validatePresence.bind(void 0,["iat","jti","ath","htm","htu"])),i=epochTime()+n;if(Math.abs(i-a.claims.iat)>300)throw OPE("DPoP Proof iat is not recent enough",JWT_TIMESTAMP_CHECK,{now:i,claims:a.claims,claim:"iat"});if(a.claims.htm!==e.method)throw OPE("DPoP Proof htm mismatch",JWT_CLAIM_COMPARISON,{expected:e.method,claims:a.claims,claim:"htm"});if("string"!=typeof a.claims.htu||normalizeHtu(a.claims.htu)!==normalizeHtu(e.url))throw OPE("DPoP Proof htu mismatch",JWT_CLAIM_COMPARISON,{expected:normalizeHtu(e.url),claims:a.claims,claim:"htu"});{const e=b64u(await crypto.subtle.digest("SHA-256",buf(t)));if(a.claims.ath!==e)throw OPE("DPoP Proof ath mismatch",JWT_CLAIM_COMPARISON,{expected:e,claims:a.claims,claim:"ath"})}{let e;switch(a.header.jwk.kty){case"EC":e={crv:a.header.jwk.crv,kty:a.header.jwk.kty,x:a.header.jwk.x,y:a.header.jwk.y};break;case"OKP":e={crv:a.header.jwk.crv,kty:a.header.jwk.kty,x:a.header.jwk.x};break;case"RSA":e={e:a.header.jwk.e,kty:a.header.jwk.kty,n:a.header.jwk.n};break;default:throw new UnsupportedOperationError("unsupported JWK key type",{cause:a.header.jwk})}const t=b64u(await crypto.subtle.digest("SHA-256",buf(JSON.stringify(e))));if(s.cnf.jkt!==t)throw OPE("JWT Access Token confirmation mismatch",JWT_CLAIM_COMPARISON,{expected:t,claims:s,claim:"cnf.jkt"})}const{0:c,1:p,2:u}=o.split("."),d=b64u(u),{jwk:l,alg:h}=a.header;if(!l)throw OPE("DPoP Proof is missing the jwk header parameter",INVALID_REQUEST,{header:a.header});const _=await importJwk(h,l);if("public"!==_.type)throw OPE("DPoP Proof jwk header parameter must contain a public key",INVALID_REQUEST,{header:a.header});await validateJwsSignature(c,p,_,d)}export async function validateJwtAccessToken(e,t,s,r){if(assertAs(e),!looseInstanceOf(t,Request))throw CodedTypeError('"request" must be an instance of Request',ERR_INVALID_ARG_TYPE);assertString(s,'"expectedAudience"');const o=t.headers.get("authorization");if(null===o)throw OPE('"request" is missing an Authorization HTTP Header',INVALID_REQUEST,{headers:t.headers});let{0:n,1:a,length:i}=o.split(" ");switch(n=n.toLowerCase(),n){case"dpop":case"bearer":break;default:throw new UnsupportedOperationError("unsupported Authorization HTTP Header scheme",{cause:{headers:t.headers}})}if(2!==i)throw OPE("invalid Authorization HTTP Header format",INVALID_REQUEST,{headers:t.headers});const c=["iss","exp","aud","sub","iat","jti","client_id"];(r?.requireDPoP||"dpop"===n||t.headers.has("dpop"))&&c.push("cnf");const{claims:p,header:u}=await validateJwt(a,checkSigningAlgorithm.bind(void 0,r?.signingAlgorithms,void 0,supported),getClockSkew(r),getClockTolerance(r),void 0).then(checkJwtType.bind(void 0,"at+jwt")).then(validatePresence.bind(void 0,c)).then(validateIssuer.bind(void 0,e)).then(validateAudience.bind(void 0,s)).catch(reassignRSCode);for(const e of["client_id","jti","sub"])if("string"!=typeof p[e])throw OPE(`unexpected JWT "${e}" claim type`,INVALID_REQUEST,{claims:p});if("cnf"in p){if(!isJsonObject(p.cnf))throw OPE('unexpected JWT "cnf" (confirmation) claim value',INVALID_REQUEST,{claims:p});const{0:e,length:t}=Object.keys(p.cnf);if(t){if(1!==t)throw new UnsupportedOperationError("multiple confirmation claims are not supported",{cause:{claims:p}});if("jkt"!==e)throw new UnsupportedOperationError("unsupported JWT Confirmation method",{cause:{claims:p}})}}const{0:d,1:l,2:h}=a.split("."),_=b64u(h),E=await getPublicSigKeyFromIssuerJwksUri(e,r,u);return await validateJwsSignature(d,l,E,_),(r?.requireDPoP||"dpop"===n||void 0!==p.cnf?.jkt||t.headers.has("dpop"))&&await validateDPoP(t,a,p,r).catch(reassignRSCode),p}function reassignRSCode(e){throw e instanceof OperationProcessingError&&e?.code===INVALID_REQUEST&&(e.code=INVALID_RESPONSE),e}export async function backchannelAuthenticationRequest(e,t,s,r,o){assertAs(e),assertClient(t);const n=resolveEndpoint(e,"backchannel_authentication_endpoint",t.use_mtls_endpoint_aliases,!0!==o?.[allowInsecureRequests]),a=new URLSearchParams(r);a.set("client_id",t.client_id);const i=prepareHeaders(o?.headers);return i.set("accept","application/json"),authenticatedRequest(e,t,s,n,a,i,o)}export async function processBackchannelAuthenticationResponse(e,t,s){if(assertAs(e),assertClient(t),!looseInstanceOf(s,Response))throw CodedTypeError('"response" must be an instance of Response',ERR_INVALID_ARG_TYPE);checkAuthenticationChallenges(s),await checkOAuthBodyError(s,200,"Backchannel Authentication Endpoint"),assertReadableResponse(s);const r=await getResponseJsonBody(s);assertString(r.auth_req_id,'"response" body "auth_req_id" property',INVALID_RESPONSE,{body:r});let o="number"!=typeof r.expires_in?parseFloat(r.expires_in):r.expires_in;return assertNumber(o,!0,'"response" body "expires_in" property',INVALID_RESPONSE,{body:r}),r.expires_in=o,void 0!==r.interval&&assertNumber(r.interval,!1,'"response" body "interval" property',INVALID_RESPONSE,{body:r}),r}export async function backchannelAuthenticationGrantRequest(e,t,s,r,o){assertAs(e),assertClient(t),assertString(r,'"authReqId"');const n=new URLSearchParams(o?.additionalParameters);return n.set("auth_req_id",r),tokenEndpointRequest(e,t,s,"urn:openid:params:grant-type:ciba",n,o)}export async function processBackchannelAuthenticationGrantResponse(e,t,s,r){return processGenericAccessTokenResponse(e,t,s,void 0,r)}export async function dynamicClientRegistrationRequest(e,t,s){assertAs(e);const r=resolveEndpoint(e,"registration_endpoint",t.use_mtls_endpoint_aliases,!0!==s?.[allowInsecureRequests]),o=prepareHeaders(s?.headers);o.set("accept","application/json"),o.set("content-type","application/json");const n="POST";s?.DPoP&&(assertDPoP(s.DPoP),await s.DPoP.addProof(r,o,n,s.initialAccessToken)),s?.initialAccessToken&&o.set("authorization",`${o.has("dpop")?"DPoP":"Bearer"} ${s.initialAccessToken}`);const a=await(s?.[customFetch]||fetch)(r.href,{body:JSON.stringify(t),headers:Object.fromEntries(o.entries()),method:n,redirect:"manual",signal:signal(r,s?.signal)});return s?.DPoP?.cacheNonce(a),a}export async function processDynamicClientRegistrationResponse(e){if(!looseInstanceOf(e,Response))throw CodedTypeError('"response" must be an instance of Response',ERR_INVALID_ARG_TYPE);checkAuthenticationChallenges(e),await checkOAuthBodyError(e,201,"Dynamic Client Registration Endpoint"),assertReadableResponse(e);const t=await getResponseJsonBody(e);return assertString(t.client_id,'"response" body "client_id" property',INVALID_RESPONSE,{body:t}),void 0!==t.client_secret&&assertString(t.client_secret,'"response" body "client_secret" property',INVALID_RESPONSE,{body:t}),t.client_secret&&assertNumber(t.client_secret_expires_at,!0,'"response" body "client_secret_expires_at" property',INVALID_RESPONSE,{body:t}),t}export async function resourceDiscoveryRequest(e,t){return performDiscovery(e,"resourceIdentifier",(e=>(prependWellKnown(e,".well-known/oauth-protected-resource",!0),e)),t)}export async function processResourceDiscoveryResponse(e,t){const s=e;if(!(s instanceof URL)&&s!==_nodiscoverycheck)throw CodedTypeError('"expectedResourceIdentifier" must be an instance of URL',ERR_INVALID_ARG_TYPE);if(!looseInstanceOf(t,Response))throw CodedTypeError('"response" must be an instance of Response',ERR_INVALID_ARG_TYPE);if(200!==t.status)throw OPE('"response" is not a conform Resource Server Metadata response (unexpected HTTP status code)',RESPONSE_IS_NOT_CONFORM,t);assertReadableResponse(t);const r=await getResponseJsonBody(t);if(assertString(r.resource,'"response" body "resource" property',INVALID_RESPONSE,{body:r}),s!==_nodiscoverycheck&&new URL(r.resource).href!==s.href)throw OPE('"response" body "resource" property does not match the expected value',JSON_ATTRIBUTE_COMPARISON,{expected:s.href,body:r,attribute:"resource"});return r}async function getResponseJsonBody(e,t=assertApplicationJson){let s;try{s=await e.json()}catch(s){throw t(e),OPE('failed to parse "response" body as JSON',PARSE_ERROR,s)}if(!isJsonObject(s))throw OPE('"response" body must be a top level object',INVALID_RESPONSE,{body:s});return s}export const _nopkce=nopkce;export const _nodiscoverycheck=Symbol();export const _expectedIssuer=Symbol();
//# sourceMappingURL=/sm/1a24676815d5b0424d0895702a4c4376f9dbeedd5b679fd20809c22dfeb66661.map